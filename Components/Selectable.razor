@using LayoutDesigner.Models
@using LayoutDesigner.Pages
@implements IDisposable
@inject IJSRuntime JS

<div id="container" style="width:@WidthPx;height:@HeightPx;">
	<div class="@selectedClass" id="navi" @onclick="Select" @onclick:stopPropagation="true" />
	<div @onclick="Select" @onclick:stopPropagation="true" @ref="contentContainer">
		@ChildContent
	</div>
</div>

@code {
	[CascadingParameter] Container? Container { get; set; }
	[CascadingParameter] public LayoutControlData? LayoutControlData { get; set; }

	[Parameter] public RenderFragment? ChildContent { get; set; }
	[Parameter] public bool HideSelection { get; set; }

	private Size _size = new ();

	private class Size
	{
		public double width { get; set; }
		public double height { get; set; }
	}

	private async Task UpdateElementSize()
	{
		_size = await JS.InvokeAsync<Size>("getElementSize", contentContainer, 2);
	}

	//private string WidthPx => $"{LayoutControlData?.Width ?? 120}px";
	private string HeightPx => $"{_size.height}px";
	private string WidthPx => $"{_size.width}px";

	private bool _containerEventsRegistered = false;
	private Guid _id;
	private string selectedClass = "";

	private ElementReference contentContainer;

	private void Select()
	{
		if (LayoutControlData != null && LayoutControlData.Selectable)
			Container?.Select(LayoutControlData);
		else
			Container?.ClearSelection();
	}

	protected override void OnParametersSet()
	{
		base.OnParametersSet();

		if (Container != null && !_containerEventsRegistered) 
		{
			Container.SelectionChanged += OnSelectionChanged;
			_containerEventsRegistered = true;
		}
	}

	void IDisposable.Dispose()
	{
		if (Container != null)
			Container.SelectionChanged -= OnSelectionChanged;
	}

	private bool IsSelected => Container?.Selection == LayoutControlData && !HideSelection;

	private void OnSelectionChanged(LayoutControlData selectedData)
	{
		var oldClass = selectedClass;
		selectedClass = (selectedData == LayoutControlData && !HideSelection) ? "selected" : "";
		if (oldClass != selectedClass)
			StateHasChanged();
	}

	protected override async void OnAfterRender(bool firstRender)
	{
		base.OnAfterRender(firstRender);
		await UpdateElementSize();
	}

	private bool _resizing;
	private double _startX, _startY;
	private int _startWidth, _startHeight;

	private void StartResize(MouseEventArgs e, string handle)
	{
		_resizing = true;
		_startX = e.ClientX;
		_startY = e.ClientY;
		_startWidth = LayoutControlData?.Width ?? 120;
		_startHeight = LayoutControlData?.Height ?? 40;
		// Attach mousemove/mouseup handlers (see below)
	}

	// Handle mousemove/mouseup to update size and clear _resizing
}
